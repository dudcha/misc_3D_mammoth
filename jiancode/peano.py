#!/usr/bin/python

#peano.py
#by Erez Lieberman-Aiden
#modified by Jian Li

#this is the main Peano curve program
#it loads curve algorithms from other files using the from command
#for example, 'from Hilbert import *' will load the Hilbert curve
#for example, 'from Peano import *' will load the Peano curve

#this is for curves whose teragons live on a square lattice and do not self-intersect
#for other cases (hexagonal lattice and/or self-intersecting teragons)
#see Hpeano.py, Xpeano.py, XHpeano.py
#These are slightly modified versions differing in the posarray and contact functions

from time import time
from sys import argv, stdout
from numpy import array, dot, zeros
from math import log, ceil


try: jump=int(argv[3])
except: jump=1

#comment one of these out in order to load it
#the files are located in the 'curves' directory
#so you need to put them in the root directory for them to work

#from Hilbert import *
#from Peano import *
#from Sympeano import *
#from Lego import *

#from Knot import *
#from Openknot import *
#from Hilbert3D import *
#from Jigsaw3D import *
#from Jigsaw import *

#from Moore import *
#from Sierpinski import *
#from Qgosper import *

#from Peano3D import *

#from Peanomatic import *
#from Peanomatic4x4 import *
#from Quartet import *
#from DickauHilbert import *

#!these use Xpeano because they self-intersect
#from Dragon import *
#from Dekking import *
#from Qkoch import *
#from Levy import *
#from PeanoII import *

#curves which are on hexagonal lattices use Hpeano.py
#curves which are on hexagonal lattices AND self-intersect use XHpeano.py
#but these are generated by Mathematica, which outputs their poslists to a txt file
#then, the Python code reads in the poslists


output_directory='output/'

def message(text):
	print '%10.5f'%(time()-benchmark)+'\t'+text

benchmark=time()
message(name+' '+argv[1])

#rewrites the string using rewrite
def step(symblist):
	out=[]
	for item in symblist:
		out.extend(rewrite[item])
	return out

#rewrites the specified number of times
#uses step
def iterate(symblist,steps):
	for i in range(steps-1):
		message('iteration\t'+`i+1`)
		symblist=step(symblist)
	return symblist

#converts to geometric instructions
#uses iterate
def instructions(symblist,steps):
	symblist=iterate(symblist,steps)
	message('alphabetize...')
	out=[]
	for symbol in symblist:
		out.extend(alphabet[symbol])
	message('done')
	return out


#returns a list of position coordinates
#uses instructions
def poslist(symblist, steps):
	#transposed rotation matrices
	#right multiply for rotations from the fixed reference frame
	#left multiply for turtle rotations
	#dependent on Processing coordinate specifications
	#(x-axis points right, y-axis points down, z-axis points out)
	rot={}
	rot['+']=array([	[0,1,0],	[-1,0,0],	[0,0,1]])
	rot['-']=array([	[0,-1,0],	[1,0,0],	[0,0,1]])
	rot['L']=array([	[0,0,1],	[0,1,0],	[-1,0,0]])
	rot['R']=array([	[0,0,-1],	[0,1,0],	[1,0,0]])
	rot['U']=array([	[1,0,0],	[0,0,1],	[0,-1,0]])
	rot['D']=array([	[1,0,0],	[0,0,-1],	[0,1,0]])

	delta={}
	delta['F']=array([1,0,0])
	delta['l']=array([-1,0,0])
	delta['r']=array([1,0,0])
	delta['u']=array([0,-1,0])
	delta['d']=array([0,1,0])
	delta['i']=array([0,0,-1])
	delta['o']=array([0,0,1])

	delta['1']=array([1,-1,0])
	delta['2']=array([-1,-1,0])
	delta['3']=array([-1,1,0])
	delta['4']=array([1,1,0])

	orientation = array([[1,0,0],[0,1,0],[0,0,1]])
	position = array([0,0,0])
	out=[]
	out.append(list(position))
	counter=0
	for i in instructions(symblist, steps):
		if counter%1000000==0:
			message('poslist\t'+`counter`)
		try:
			orientation=dot(rot[i],orientation)
		except:
			position+=dot(delta[i],orientation)
			out.append(list(position))
		counter+=1
	return out



#returns an array with the numbered steps
#uses poslist
def posarray(symblist,steps,check=1):	#check means check if there are self-intersections
	list=poslist(symblist,steps)
	message('posarray...')
	dim=len(list[0])
	bounds=[]
	for d in range(dim):
		bounds.append(min([item[d] for item in list]))
		bounds.append(max([item[d] for item in list]))
	minx,maxx,miny,maxy,minz,maxz=bounds
	out=zeros((1+maxz-minz,1+maxy-miny,1+maxx-minx),int)
	for i in range(len(list)):
		if check and out[list[i][2]-minz,list[i][1]-miny,list[i][0]-minx] != 0:
			return 'error'
		out[list[i][2]-minz,list[i][1]-miny,list[i][0]-minx]=i+1
	message('done')
	return out

#returns a list of contacts and potential contacts as a function of distance
#uses posarray
def contacts(symblist,steps):
	A=posarray(symblist,steps)
	message('contacts...')
	strandsize=int(A.max())
	actual=[0]*strandsize
	for i in range(A.shape[0]):
		for j in range(A.shape[1]):
			for k in range(A.shape[2]):
				if A[i][j][k]!=0:
					valref=A[i][j][k]
					comparevals=[]
					if i>0 and A[(i-1,j,k)]: comparevals.append(A[(i-1,j,k)])
					if j>0 and A[(i,j-1,k)]: comparevals.append(A[(i,j-1,k)])
					if k>0 and A[(i,j,k-1)]: comparevals.append(A[(i,j,k-1)])
					for val in comparevals:
						actual[abs(valref-val)]+=1
	possible=[0]+[strandsize-i for i in range(1,strandsize)]
	print actual, possible #comment out for long poslists#####
	message('done')
#	logbase=int(round((1+len(alphabet[list[0]]))**(1./3)))##not very general. cf z-order (no grammar) and hilbert (rotations)
	logbase=int(argv[2])######
	return actual,possible,logbase


#uses contacts
def plot(actual,possible,logbase):
	from pylab import polyfit
	from pylab import close,plot,savefig,legend,xlabel,ylabel,title

	top=log(len(actual)-1,logbase)
	lbins=range(0,int(ceil(top))+1,1)

	print 'top:\t'+`top`
	print 'lbins:\t'+`lbins`
	
	binact=[0]*len(lbins)
	binposs=[0]*len(lbins)
	
	currbin=0

	for i in range(1,len(actual)):
		while log(i,logbase)>lbins[currbin]:
			currbin+=1
		binact[currbin]+=actual[i]
		binposs[currbin]+=possible[i]
    	#moves startval to the last empty bin other than the last bin
	startval=-1
	for i in range(len(binact)-1):
		if binact[i]==0:
			startval=i
			print 'startval moved:\t'+`startval`

	#moves stopval back one if its bin is empty
	stopval=len(binact)
	if binact[-1]==0:
		stopval=len(binact)-1
		print 'stopval moved:\t'+`stopval`

	print 'lbins:\t'+`lbins`
	print 'binact:\t'+`binact`
	print 'binposs:\t'+`binposs`

	# ratioindex avoids all zero acts
	ratioindex=range(startval+1,stopval)

	print 'ratioindex:\t'+`ratioindex`

	ratio=[log(float(binact[i])/binposs[i],logbase) for i in ratioindex]
	# range defines the number of excluded ends
	for start in range(0,8):
		for end in range(0,8):
			try:
				fitall=polyfit(ratioindex[start:len(ratioindex)-end:jump],ratio[start:len(ratioindex)-end:jump],1)
	
				print fitall, start, end

				close('all')
				a=plot(ratioindex,ratio)
			#	a=plot(ratioindex[1:-1],[fitall[1]+(fitall[0]*i) for i in ratioindex[1:-1]],'r--',label='Slope: '+`fitall[0]`[:6])
				a=plot(ratioindex[start:len(ratioindex)-end:jump],[fitall[1]+(fitall[0]*i) for i in ratioindex[start:len(ratioindex)-end:jump]],'r--',label='Slope:'+`fitall[0]`[:7])
	#			a=plot(ratioindex,[0+(-1.333*i) for i in ratioindex],'g--',label='Slope:'+`-1.333`[:6])#
			#	a=plot(ratioindex,[0+(-1.5*i) for i in ratioindex],'g--',label='Slope:'+`-1.500`[:6])#
				a=xlabel('Distance (log '+`logbase`+')')
				a=ylabel('Contact Probability (log '+`logbase`+')')
				a=legend()
			#	savefig(output_directory+'Scaling.'+name+'.'+`len(actual)`+'.log'+`logbase`+'.png')
				if jump==1:
					savefig(output_directory+'Scaling.'+name+'.'+'%.8i'%len(actual)+'.log'+`logbase`+'.'+`start`+'.'+`end`+'.png')
				else:
					savefig(output_directory+'Scaling.'+name+'.'+'%.8i'%len(actual)+'.log'+`logbase`+'.step'+`jump`+'.'+`start`+'.'+`end`+'.png')
			except:
				print 'error', start, end


def write(end):
	for number in range(1,end+1):
		f=open('poslists/'+name+'/'+name+`number`+'.txt', 'w')
		for point in poslist(symbols,number):
			f.write(`point[0]`+'\t'+`point[1]`+'\t'+`point[2]`+'\n')
		f.close()
		print 'written'+`number`
def writereversed(end):
	for number in range(1,end+1):
		f=open('poslists/'+name+'/y-reversed/'+name+`number`+symbols+'.txt', 'w')
		for point in poslist(symbols,number):
			f.write(`point[0]`+'\t'+`-point[1]`+'\t'+`point[2]`+'\n')
		f.close()
		print 'written'+`number`

#for visualizing shapes
print posarray(symbols,int(argv[1]),check=0)
#print ''.join(iterate(symbols, int(argv[1])))
#actual,possible,logbase=contacts(symbols,int(argv[1]))
#print actual, possible
#plot(actual,possible,logbase)

#write(9)
#writereversed(2)


#iteration, logbase, step



